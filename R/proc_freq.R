

#' @title Generates Frequency Statistics
#' @encoding UTF-8
#' @description Here is a sample function.
#' @details
#' Some details about the sample function.
#' @param data The input data frame to perform frequency calculations on.
#' @param by An optional by group.
#' @param tables The variable or variables to perform frequency counts on.
#' @param table_options The option specifications for the table parameter.
#' @param weight An optional weight parameter.
#' @param weight_options The option specifications for the weight parameter.
#' @param output The directory path or libname to output data generated by
#' the \code{proc_freq} function.
#' @param view Whether to display procedure results in the viewer.  Valid values
#' are TRUE and FALSE.  Default is TRUE.
#' @param report_type The output type for any report output.  Valid values are
#' 'HTML', 'TXT', 'PDF', 'RTF', 'DOCX'.  Multiple outputs can be
#' requested by passing a vector of output types.  If the report_location parameter
#' is specified, the outputs will be written to that location.  Otherwise,
#' they will be written to a temp directory.  The default value is NULL.
#' @param report_location A path to write any report output requested by
#' the print parameter. The path may be either a full path with file name,
#' or a directory name.  If the file name is not specified, the procedure
#' type will be used.  If no path is specified, files will be
#' written to a temp directory.  Default is NULL.
#' @param titles A vector of one or more titles to use for the report output.
#' @return A list of data frames that contain the requested frequency tables.
#' The list item names are specified in the \code{tables} parameter.
#' @import fmtr
#' @export
proc_freq <- function(data,
                      by = NULL,
                      tables = NULL,
                      table_options = NULL,
                      weight = NULL,
                      weight_options = NULL,
                      view = TRUE,
                      output = NULL,
                      report_type = NULL,
                      report_location = NULL,
                      titles = NULL) {

  res <- list()
  # print("Orig print_location")
  # print(print_location)
  #browser()

  # Loop through tabel requests
  for (i in seq_len(length(tables))) {

    nm <- names(tables)[i]
    tb <- tables[i]
    #browser()
    out <- i == length(tables) & has_option(table_options, "out")

    crstab <- NULL

    # Split cross variables
    splt <- trimws(strsplit(tb, "*", fixed = TRUE)[[1]])

    # Perform either one-way or two-way frequency count
    if (length(splt) == 1) {

      result <- freq_oneway(data, tb, weight, table_options, out)

    } else if (length(splt) == 2) {

      result <- freq_twoway(data, splt[1], splt[2], weight, table_options, out)

      crstab <- cross_tab(result, table_options, splt[1], splt[2])

    } else {

      stop("Procedure does not yet support n-way frequencies.")
    }

    # If a cross tab was produced, add it to result
    if (!is.null(crstab)) {

      if (is.null(nm))
        res[[tb]] <- crstab
      else if (nchar(nm) == 0)
        res[[tb]] <- crstab
      else
        res[[nm]] <- crstab

      if ("out" %in% names(table_options) & i == length(tables)) {

        res[[table_options[["out"]]]] <- result
      }

    } else { # Otherwise add one-way to result

      if (is.null(nm))
        res[[tb]] <- result
      else if (nchar(nm) == 0)
        res[[tb]] <- result
      else
        res[[nm]] <- result

    }
  }

  # Create output reports if requested
  if (!is.null(report_type)) {

    loc <- get_location("freq", report_location)
    out <- output_report(res, proc_type = 'freq', dir_name = loc["dir_name"],
                         file_name = loc["file_name"], out_type = report_type,
                         titles = titles, margins = 1)


  }

  # Create viewer report if requested
  if (view == TRUE) {


    vrfl <- tempfile()

    out <- output_report(res, proc_type = 'freq', dir_name = dirname(vrfl),
                         file_name = basename(vrfl), out_type = "HTML",
                         titles = titles, margins = .5, viewer = TRUE)

    show_viewer(out)
  }

  return(res)

}


#' @import fmtr
#' @import stats
#' @noRd
freq_oneway <- function(data, tb, weight, options, out = FALSE) {

  # Get target variable vector
  var <- data[[tb]]

  # Get frequency counts
  if (is.null(weight)) {

    categories <- names(sort(table(var)))
    frequencies <- as.vector(sort(table(var)))

  } else {

    cnts <- aggregate(data[[weight]], list(data[[tb]]), FUN = sum)
    categories <- cnts$Group.1
    frequencies <- cnts$x
  }

  # Perform calculations
  n <- sum(frequencies)
  percentages <- frequencies / n * 100
  cum_frequencies <- cumsum(frequencies)
  cum_percentages <- cumsum(percentages)


  # Create result data frame
  result <- data.frame("Category" = categories,
                       "Frequency" = frequencies,
                       "Percent" = percentages,
                       "Cum_Freq" = cum_frequencies,
                       "Cum_Pct" = cum_percentages,
                       stringsAsFactors = FALSE)



  # Get any existing label for target variable
  lbl <- attr(data[[tb]], "label")

  if (is.null(lbl))
    lbl <- tb

  # Clear out any names
  names(tb) <- NULL

  # Apply default labels
  labels(result) <- c(Category = tb,
                      Cum_Freq = "Cumulative Frequency",
                      Cum_Pct = "Cumulative Percent")

  # Apply default formats
  formats(result) <- list(Cum_Pct = "%.2f",
                          Percent = "%.2f")

 # browser()

  # Kill freq if requested
  if ((!option_true(options, "freq", TRUE))) {

    result[["Frequency"]] <- NULL
  }

  # Kill pct if requested
  if ((!option_true(options, "pct", TRUE))) {

    result[["Percent"]] <- NULL
  }

  # Kill cum freq if requested
  if ((out == FALSE & !option_true(options, "cumsum", TRUE)) |
      (out == TRUE & !option_true(options, "outcum", TRUE))) {

    result[["Cum_Freq"]] <- NULL
  }

  # Kill cum pct if requested
  if ((out == FALSE & !option_true(options, "cumpct", TRUE)) |
      (out == TRUE & !option_true(options, "outcum", TRUE))) {

    result[["Cum_Pct"]] <- NULL
  }


  # Add spanning headers
  spn <- span_spec(label = lbl, 1, ncol(result), 1)
  attr(result, "spans") <- list(spn)


  return(result)
}


#' @import fmtr
#' @import stats
#' @noRd
freq_twoway <- function(data, tb1, tb2, weight, options, out = FALSE) {

  # Assign 1 to count column
  data[["__cnt"]] <- 1

  # Get target variables into vectors
  v1 <- data[[tb1]]
  v2 <- data[[tb2]]

  # Get unique values of variables
  t1 <- names(sort(table(v1)))
  t2 <- names(sort(table(v2)))

  # Get unique combinations of variable values for zero-fill
  ex <- expand.grid(tb1 = t1, tb2 = t2, stringsAsFactors = FALSE)

  # Assign zero fill value
  ex[["__cnt"]] <- 0

  # Use weight variable if requested
  if (is.null(weight)) {

    c1 <- data[["__cnt"]]

  } else {

    c1 <-data[[weight]]

  }

  # Append zero fills
  if (option_true(options, "sparse", TRUE)) {
    c1 <- append(c1, ex[["__cnt"]])
    v1 <- append(v1, ex[["tb1"]])
    v2 <- append(v2, ex[["tb2"]])
  }

  # Get frequencies
  cnts <- aggregate(c1, list(v1, v2), FUN = sum)
  categories1 <- cnts$Group.1
  categories2 <- cnts$Group.2
  frequencies <- cnts$x

  # Perform calculations
  n <- sum(frequencies)
  percentages <- frequencies / n * 100


  # Create result data frame
  result <- data.frame("Category1" = categories1,
                       "Category2" = categories2,
                       "Frequency" = frequencies,
                       "Percent" = percentages,
                       stringsAsFactors = FALSE)

  # Sort result data frame
  result <- result[order(result$Category1, result$Category2), ]

  # Get labels on target variables if they exist
  lbl1 <- attr(data[[tb1]], "label")
  lbl2 <- attr(data[[tb2]], "label")

  if (is.null(lbl1))
    lbl1 <- tb1
  if (is.null(lbl2))
    lbl2 <- tb2

  # Assign labels
  labels(result) <- c(Category1 = lbl1,
                      Category2 = lbl2)

  # Assign default formats
  formats(result) <- list(Percent = paste0("%.4f"))

  # Kill freq if requested
  if ((!option_true(options, "freq", TRUE))) {

    result[["Frequency"]] <- NULL
  }

  # Kill pct if requested
  if ((!option_true(options, "pct", TRUE))) {

    result[["Percent"]] <- NULL
  }

  # Kill cum freq if requested
  if ((out == FALSE & !option_true(options, "cumsum", TRUE)) |
      (out == TRUE & !option_true(options, "outcum", TRUE))) {

    result[["Cum_Freq"]] <- NULL
  }

  # Kill cum pct if requested
  if ((out == FALSE & !option_true(options, "cumpct", TRUE)) |
      (out == TRUE & !option_true(options, "outcum", TRUE))) {

    result[["Cum_Pct"]] <- NULL
  }


  return(result)

}

#' @import fmtr
#' @import stats
#' @noRd
cross_tab <- function(freqdata, options, var1, var2) {

  lbl1 <- attr(freqdata$Category1, "label")
  lbl2 <- attr(freqdata$Category2, "label")

  # Group by both dimensions
  cat1grp <- aggregate(freqdata$Frequency, list(freqdata$Category1), FUN=sum)
  cat2grp <- aggregate(freqdata$Frequency, list(freqdata$Category2), FUN=sum)

  # Create lookup from cat1 group (rows)
  lkp1 <- cat1grp$x
  names(lkp1) <- cat1grp$Group.1

  # Create lookup from cat2 group (columns)
  lkp2 <- cat2grp$x
  names(lkp2) <- cat2grp$Group.1

  # Assign data to new variable
  dt <- freqdata

  # Create freq columns for both dimensions
  dt$rowcnt <- lkp1[dt$Category1]
  dt$colcnt <- lkp2[dt$Category2]

  # Create percentages for both dimensions
  dt$Percentage <- dt$Percentage
  dt$rowpct <- dt$Frequency / dt$rowcnt * 100
  dt$colpct <- dt$Frequency / dt$colcnt * 100

  dt1 <- reshape(dt, timevar = "Category2", idvar = "Category1",
                 v.names = "Frequency", direction = "wide",
                 drop = c("Percent", "rowcnt", "colcnt", "rowpct", "colpct"))
  dt1$Order <- 1
  dt1$Statistic <- "Frequency"
  names(dt1) <- gsub("Frequency.",  "", names(dt1), fixed = TRUE)

  dt2 <- reshape(dt, timevar = "Category2", idvar = "Category1",
                 v.names = "Percent", direction = "wide",
                 drop = c("Frequency", "rowcnt", "colcnt", "rowpct", "colpct"))
  dt2$Order <- 2
  dt2$Statistic <- "Percent"
  names(dt2) <- gsub("Percent.",  "", names(dt2), fixed = TRUE)


  dt3 <- NULL
  if (get_option(options, "rowpct", TRUE) == TRUE) {
    dt3 <- reshape(dt, timevar = "Category2", idvar = "Category1",
                   v.names = "rowpct", direction = "wide",
                   drop = c("Percent", "rowcnt", "colcnt", "Frequency", "colpct"))
    dt3$Order <- 3
    dt3$Statistic <- "Row Pct"
    names(dt3) <- gsub("rowpct.",  "", names(dt3), fixed = TRUE)
  }

  dt4 <- NULL
  if (get_option(options, "colpct", TRUE) == TRUE) {
    dt4 <- reshape(dt, timevar = "Category2", idvar = "Category1",
                   v.names = "colpct", direction = "wide",
                   drop = c("Percent", "rowcnt", "colcnt", "Frequency", "rowpct"))
    dt4$Order <- 4
    dt4$Statistic <- "Col Pct"
    names(dt4) <- gsub("colpct.",  "", names(dt4), fixed = TRUE)
  }

  ret <- rbind(dt1, dt2, dt3, dt4,
               make.row.names = FALSE,
               stringsAsFactors = FALSE)

  # Get all value column names
  nnms <- names(ret)[!names(ret) %in% c("Category1", "Order", "Statistic")]

  # Sort data frame by category and order
  ret <- ret[order(ret$Category1, ret$Order), c("Category1", "Statistic", nnms) ]

  # Rename to Category so output_report() will recognize as a stub
  names(ret)[1] <- "Category"

  # Get format
  fmt <- get_option(options, "format", "%.2f")

  # Create formatting list
  lst <- list(Frequency = "%d", Percent = fmt,
              'Row Pct' = fmt, 'Col Pct' = fmt)
  fl <- as.flist(lst, type = "row", lookup = ret$Label)

  # Assign flist to data columns
  fmts <- list()
  for (nm in nnms) {
    fmts[[nm]] <- fl
  }
  formats(ret) <- fmts

  # Assign label to Category
  attr(ret$Category, "label") <- lbl1

  # Add spanning headers
  lbl <- paste0("Table of ", var1, " by ", var2)
  spn2 <- span_spec(label = lbl, 1, ncol(ret), 2)
  spn1 <- span_spec(label = lbl2, 3, ncol(ret), 1)
  attr(ret, "spans") <- list(spn1, spn2)

  return(ret)
}


