
#' @title Calculates Summary Statistics
#' @encoding UTF-8
#' @description Here is a sample function.
#' @details
#' Some details about the sample function.
#' @param data The input data frame for which calculate summary statistics.
# @param by An optional by group.
# @param class The variable or variables to perform frequency counts on.
# @param class_options The option specifications for the table parameter.
#' @param var The variable(s) to calculate summary statistics for.
#' @param stats The a quoted vector of summary statistics keywords.  Valid
#' keywords are: "n", "means", "median", "std", "min", "max", and "range".
# @param weight An optional weight parameter.
# @param weight_options The option specifications for the weight parameter.
# @param output The directory path or libname to output data generated by
# the \code{proc_freq} function.
#' @param view Whether to display the report in the interactive viewer.  Valid
#' values are TRUE and FALSE.  Default is TRUE.
#' @param report_type The output type for any report output.  Valid values are
#' 'HTML', 'TXT', 'PDF', 'RTF', 'DOCX'.  Multiple outputs can be
#' requested by passing a vector of output types.  If the report_location parameter
#' is specified, the outputs will be written to that location.  Otherwise,
#' they will be written to a temp directory.  The default value is NULL.
#' @param report_location A path to write any report output requested by
#' the print parameter. The path may be either a full path with file name,
#' or a directory name.  If the file name is not specified, the procedure
#' type will be used.  If no path is specified, files will be
#' written to a temp directory.  Default is NULL.
#' @param report_style A theme name or style object to use on the report output.
#' See the \code{\link[reporter]{create_style}} in the \strong{reporter}
#' package for additional information on styles.
#' @param titles A vector of one or more titles to use for the report output.
#' @param piped Whether or not the \code{proc_freq} function is part of a data
#' pipeline.  Set this parameter to TRUE if you want the function to return
#' a single dataset instead of a list of datasets.  If there is more than one
#' table requested, the function will return the last requested table.
#' @return A list of data frames that contain the requested frequency tables.
#' @import fmtr
#' @export
proc_means <- function(data,
              #         by = NULL,
              #         class = NULL,
              #         class_options = NULL,
                       var = NULL,
                       stats = NULL,
              #         weight = NULL,
              #         weight_options = NULL,
                       view = TRUE,
              #         output = NULL,
                       report_type = NULL,
                       report_location = NULL,
                       report_style = NULL,
                       titles = NULL,
                       piped = FALSE) {


  res <- list()

  res[[length(res) + 1]] <- get_summaries(data, var, stats)



  # Create output reports if requested
  if (!is.null(report_type)) {

    loc <- get_location("means", report_location)
    out <- output_report(res, proc_type = 'means', dir_name = loc["dir_name"],
                         file_name = loc["file_name"], out_type = report_type,
                         style = report_style,
                         titles = titles, margins = 1)


  }

  # Create viewer report if requested
  if (view == TRUE) {


    vrfl <- tempfile()

    out <- output_report(res, proc_type = 'means', dir_name = dirname(vrfl),
                         file_name = basename(vrfl), out_type = "HTML",
                         style = report_style,
                         titles = titles, margins = .5, viewer = TRUE)

    show_viewer(out)
  }


  if (piped)
    res <- res[[length(res)]]



  return(res)
}


get_summaries <- function(data, var, stats) {


  ret <- NULL

  for (nm in var) {

    if (!nm %in% names(data)) {

      stop(paste0("Variable '", nm, "' not found on input dataset."))
    } else {

      rw <- data.frame(Variable = nm, stringsAsFactors = FALSE)
      var <- data[[nm]]

      for (st in stats) {

        if (st == "n") {

          rw[["N"]] <- sum(!is.na(var))
        }

        if (st == "mean") {

          rw[["Mean"]] <- mean(var, na.rm = TRUE)
        }

        if (st == "max") {

          rw[["Maximum"]] <- max(var, na.rm = TRUE)
        }

        if (st == "min") {

          rw[["Minimum"]] <- min(var, na.rm = TRUE)
        }

        if (st == "median") {

          rw[["Median"]] <- median(var, na.rm = TRUE)
        }

        if (st == "std") {

          rw[["Std_Dev"]] <- sd(var, na.rm = TRUE)
        }

        if (st == "range") {

          rng <- range(var, na.rm = TRUE)
          if (!is.null(rng) & length(rng) == 2)
            rw[["Range"]] <- rng[2] - rng[1]
          else
            rw[["Range"]] <- NA
        }
      }

    }

    if (is.null(ret))
      ret <- rw
    else
      ret <- rbind(ret, rw)
  }

  return(ret)

}


