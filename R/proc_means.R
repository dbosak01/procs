
#' @title Calculates Summary Statistics
#' @encoding UTF-8
#' @description The \code{proc_means} function generates summary statistics
#' for selected variable on the input dataset.  The variables are identified
#' on the \code{var} parameter.  The statistics to perform are identified
#' on the \code{stats} parameter.  By default, results are returned as a list,
#' of tibbles.
#' @details
#' Some details about the sample function.
#'
#'
#' All statistics remove missing values by default.  Should there be an
#' option to include them?
#'
#' @section Statistics Options:
#' \itemize{
#'   \item{\strong{CSS}: Corrected Sum of Squares.
#'
#'   }
#'   \item{\strong{CV}: Coefficient of Variation.
#'
#'   }
#' }
#'
#' @section Using Weights:
#' Need a section explaining how to use weights.
#'
#' @section Data Constraints:
#' Explain limits of data for each stat option.  Number of non-missing
#' values, etc.
#'
#'
#' @param data The input data frame for which calculate summary statistics.
#' @param by An optional by group. You may
#' pass unquoted variable names to this parameter using the \code{\link{v}}
#' function.
# @param class The variable or variables to perform frequency counts on.
# @param class_options The option specifications for the table parameter.
#' @param var The variable(s) to calculate summary statistics for. You may
#' pass unquoted variable names to this parameter using the \code{\link{v}}
#' function.
#' @param stats A quoted vector of summary statistics keywords.  Valid
#' keywords are: "css", "clm", "cv", "n", "lclm", "mean", "median", "mode",
#' "min", "max",
#' "nmiss", "nobs", "range", "std", "stderr", "sum", "uclm", "var",
#' "q1", "q3", "p1", "p5", "p10", "p20", "p25", "p30", "p40",
#' "p50", "p60", "p70", "p75", "p80", "p90",
#' "p95", "p99", "qrange". You may
#' pass unquoted variable names to this parameter using the \code{\link{v}}
#' function.
# @param weight An optional weight parameter.
# @param weight_options The option specifications for the weight parameter.
# @param output The directory path or libname to output data generated by
# the \code{proc_freq} function.
#' @param view Whether to display the report in the interactive viewer.  Valid
#' values are TRUE and FALSE.  Default is TRUE.
#' @param report_type The output type for any report output.  Valid values are
#' 'HTML', 'TXT', 'PDF', 'RTF', 'DOCX'.  Multiple outputs can be
#' requested by passing a vector of output types.  If the report_location parameter
#' is specified, the outputs will be written to that location.  Otherwise,
#' they will be written to a temp directory.  The default value is NULL.
#' @param report_location A path to write any report output requested by
#' the print parameter. The path may be either a full path with file name,
#' or a directory name.  If the file name is not specified, the procedure
#' type will be used.  If no path is specified, files will be
#' written to a temp directory.  Default is NULL.
#' @param report_style A theme name or style object to use on the report output.
#' See the \code{\link[reporter]{create_style}} in the \strong{reporter}
#' package for additional information on styles.
#' @param titles A vector of one or more titles to use for the report output.
# @param missing Whether to include missing (NA) values in the analysis.
# By default, missing values are not included.
#' @param piped Whether or not the \code{proc_freq} function is part of a data
#' pipeline.  Set this parameter to TRUE if you want the function to return
#' a single dataset instead of a list of datasets.  If there is more than one
#' table requested, the function will return the last requested table.
#' @return A list of datasets that contain the requested summary statistics.
#' If the function is being used in a pipeline, set the
#' \code{piped} parameter to TRUE, which will return only the last table.
#' @import fmtr
#' @import tibble
#' @export
proc_means <- function(data,
                       by = NULL,
              #         class = NULL,
              #         class_options = NULL,
                       var = NULL,
                       stats = c("n", "mean", "std", "min", "max"),
              #         weight = NULL,
              #         weight_options = NULL,
                       view = TRUE,
              #         output = NULL,
              #         output_options = NULL,
                       report_type = NULL,
                       report_location = NULL,
                       report_style = NULL,
                       titles = NULL,
                      # missing = FALSE,
                       piped = FALSE) {

  # SAS seems to always ignore these
  # Not sure why R as an option to keep them
  missing <- FALSE

  # Deal with single value unquoted parameter values
  oby <- deparse(substitute(by, env = environment()))
  by <- tryCatch({if (typeof(by) %in% c("character", "NULL")) by else oby},
                 error = function(cond) {oby})

  ovar <- deparse(substitute(var, env = environment()))
  var <- tryCatch({if (typeof(var) %in% c("character", "NULL")) var else ovar},
                 error = function(cond) {ovar})

  ostats <- deparse(substitute(stats, env = environment()))
  stats <- tryCatch({if (typeof(stats) %in% c("character", "NULL")) stats else ostats},
                  error = function(cond) {ostats})

  # Parameter checks
  nms <- names(data)

  if (is.null(var)) {
    var <- c()
    for (nm in nms) {
      if (is.numeric(data[[nm]])) {

        var[length(var) + 1] <- nm
      }

    }
  }


  if (!is.null(by)) {
    if (!all(by %in% nms)) {

      stop(paste("Invalid by name: ", by[!by %in% nms], "\n"))
    }
  }

  if (is.null(var)) {
    stop("var parameter is required.")
  } else {
    if (!all(var %in% nms)) {

      stop(paste("Invalid variable name: ", var[!var %in% nms], "\n"))
    }
  }
  if (is.null(stats)) {
    stop("stats parameter is required.")
  } else {
    st <- c( "css", "cv", "n", "mean", "median", "std", "min", "max",
             "nmiss", "nobs", "range", "sum", "stderr", "var", "clm", "uclm",
             "lclm","mode", "q1", "q3", "p1", "p5", "p10", "p20",
             "p25", "p30", "p40",
             "p50", "p60", "p70", "p75", "p80", "p90",
             "p95", "p99", "qrange")
    if (!all(tolower(stats) %in% st)) {

      stop(paste("Invalid stat name: ", stats[!tolower(stats) %in% st], "\n"))
    }
  }

  # Declare return list
  res <- list()

  #browser()

  bylbls <- c()
  if (!is.null(by)) {

    lst <- unclass(data)[by]
    for (nm in names(lst))
      lst[[nm]] <- as.factor(lst[[nm]])
    dtlst <- split(data, lst, sep = "|")

    snms <- strsplit(names(dtlst), "|", fixed = TRUE)

    for (k in seq_len(length(snms))) {
      for (l in seq_len(length(by))) {
        lv <- ""
        if (!is.null(bylbls[k])) {
          if (!is.na(bylbls[k])) {
            lv <- bylbls[k]
          }
        }

        if (l == length(by))
          cma <- ""
        else
          cma <- ", "

        bylbls[k] <- paste0(lv, by[l], "=", snms[[k]][l], cma)
      }
    }

  } else {

    dtlst <- list(data)
  }

  # Loop through by groups
  for (j in seq_len(length(dtlst))) {

    # Get table for this by group
    dt <- dtlst[[j]]

    # Calculate summary statistics
    smtbl <- get_summaries(dt, var, stats, missing)


    nm <- length(res) + 1

    # Add spanning headers if there are by groups
    if (!is.null(by)) {

      # Add spanning headers
      spn <- span_spec(label = bylbls[j], 1, ncol(smtbl), 1)
      attr(smtbl, "spans") <- list(spn)

      nm <-  bylbls[j]
    }

    # Add default formats
    for (cnm in names(smtbl)) {

      if (typeof(smtbl[[cnm]]) %in% c("double")) {

        attr(smtbl[[cnm]], "format") <- "%.4f"
      }

    }

    # Convert to tibble if incoming data is a tibble
    if ("tbl_df" %in% class(data))
      res[[nm]] <- as_tibble(smtbl)
    else
      res[[nm]] <- smtbl


  }


  # Create output reports if requested
  if (!is.null(report_type)) {

    loc <- get_location("means", report_location)
    out <- output_report(res, proc_type = 'means', dir_name = loc["dir_name"],
                         file_name = loc["file_name"], out_type = report_type,
                         style = report_style,
                         titles = titles, margins = 1)


  }

  # Create viewer report if requested
  if (view == TRUE) {


    vrfl <- tempfile()

    out <- output_report(res, proc_type = 'means', dir_name = dirname(vrfl),
                         file_name = basename(vrfl), out_type = "HTML",
                         style = report_style,
                         titles = titles, margins = .5, viewer = TRUE)

    show_viewer(out)
  }


  if (piped)
    res <- res[[length(res)]]



  return(res)
}

#' @import fmtr
get_summaries <- function(data, var, stats, missing = FALSE) {

  narm <- !missing
  ret <- NULL

  for (nm in var) {

    if (!nm %in% names(data)) {

      stop(paste0("Variable '", nm, "' not found on input dataset."))
    } else {

      rw <- data.frame(Variable = nm, stringsAsFactors = FALSE)
      var <- data[[nm]]

      sts <- tolower(stats)
      #browser()

      for (st in sts) {

        if (st == "n") {

          rw[["N"]] <- sum(!is.na(var))
        }

        if (st == "css") {

          if (all(is.na(var)))
            rw[["CSS"]] <- NA
          else
            rw[["CSS"]] <- sum((var - mean(var, na.rm = narm))^2, na.rm = narm)
        }

        if (st == "cv") {

          if (all(is.na(var)))
            rw[["CV"]] <- NA
          else
            rw[["CV"]] <- sd(var, na.rm = narm) / mean(var, na.rm = narm) * 100
        }

        if (st == "mean") {

          if (all(is.na(var)))
            rw[["Mean"]] <- NA
          else
            rw[["Mean"]] <- mean(var, na.rm = narm)
        }

        if (st == "mode") {

          if (all(is.na(var)))
            rw[["Mode"]] <- NA
          else
            rw[["Mode"]] <- get_mode(var)
        }

        if (st == "max") {
          if (all(is.na(var)))
            rw[["Maximum"]] <- NA
          else
            rw[["Maximum"]] <- max(var, na.rm = narm)
        }

        if (st == "min") {

          if (all(is.na(var)))
            rw[["Minimum"]] <- NA
          else
            rw[["Minimum"]] <- min(var, na.rm = narm)
        }

        if (st == "median") {

          if (all(is.na(var)))
            rw[["Median"]] <- NA
          else
            rw[["Median"]] <- median(var, na.rm = narm)
        }

        if (st == "nobs") {

          rw[["Nobs"]] <- nrow(data)
        }

        if (st == "nmiss") {

          rw[["NMiss"]] <- sum(is.na(var))
        }

        if (st == "std") {

          if (all(is.na(var)))
            rw[["Std_Dev"]] <- NA
          else
            rw[["Std_Dev"]] <- sd(var, na.rm = narm)
        }

        if (st == "sum") {

          if (all(is.na(var)))
            rw[["Sum"]] <- NA
          else
            rw[["Sum"]] <- sum(var, na.rm = narm)
        }

        if (st == "range") {

          if (all(is.na(var))) {
            rw[["Range"]] <- NA
          } else {
          rng <- range(var, na.rm = narm)
            if (!is.null(rng) & length(rng) == 2)
              rw[["Range"]] <- rng[2] - rng[1]
            else
              rw[["Range"]] <- NA
          }
        }

        if (st == "var") {

          rw[["Variance"]] <- var(var, na.rm = narm)
        }

        if (st == "stderr") {

          rw[["Std_Err"]] <- get_stderr(var, narm)
        }



        if (st == "lclm") {

          tmp <- get_clm(var, narm)

          rw[["LCLM"]] <- tmp[["lcl"]]


        }

        if (st == "uclm") {

          tmp <- get_clm(var, narm)

          rw[["UCLM"]] <- tmp[["ucl"]]


        }


        if (st == "clm") {

          tmp <- get_clm(var, narm)

          rw[["LCLM"]] <- tmp[["lcl"]]

          rw[["UCLM"]] <- tmp[["ucl"]]


        }

        if (st == "uss") {

          rw[["USS"]] <-  sum(var^2, na.rm = narm)
        }

        if (st == "p1") {

          rw[["P1"]] <- quantile(var, probs = c(0.01), type = 2, na.rm = narm)

        }

        if (st == "p5") {

          rw[["P5"]] <- quantile(var, probs = c(0.05), type = 2, na.rm = narm)

        }

        if (st == "p10") {

          rw[["P10"]] <- quantile(var, probs = c(0.1), type = 2, na.rm = narm)

        }

        if (st == "p20") {

          rw[["P20"]] <- quantile(var, probs = c(0.2), type = 2, na.rm = narm)

        }

        if (st == "p25") {

          rw[["P25"]] <- quantile(var, probs = c(0.25), type = 2, na.rm = narm)

        }

        if (st == "q1") {

          rw[["Q1"]] <- quantile(var, probs = c(0.25), type = 2, na.rm = narm)

        }

        if (st == "p30") {

          rw[["P30"]] <- quantile(var, probs = c(0.3), type = 2, na.rm = narm)

        }
        if (st == "p40") {

          rw[["P40"]] <- quantile(var, probs = c(0.4), type = 2, na.rm = narm)

        }

        if (st == "p50") {

          rw[["P50"]] <- quantile(var, probs = c(0.5), type = 2, na.rm = narm)

        }

        if (st == "p60") {

          rw[["P60"]] <- quantile(var, probs = c(0.6), type = 2, na.rm = narm)

        }
        if (st == "p70") {

          rw[["P70"]] <- quantile(var, probs = c(0.7), type = 2, na.rm = narm)

        }

        if (st == "p75") {

          rw[["P75"]] <- quantile(var, probs = c(0.75), type = 2, na.rm = narm)

        }

        if (st == "q3") {

          rw[["Q3"]] <- quantile(var, probs = c(0.75), type = 2, na.rm = narm)

        }

        if (st == "p80") {

          rw[["P80"]] <- quantile(var, probs = c(0.8), type = 2, na.rm = narm)

        }

        if (st == "p90") {

          rw[["P90"]] <- quantile(var, probs = c(0.9), type = 2, na.rm = narm)

        }

        if (st == "p95") {

          rw[["P95"]] <- quantile(var, probs = c(0.95), type = 2, na.rm = narm)

        }

        if (st == "p99") {

          rw[["P99"]] <- quantile(var, probs = c(0.99), type = 2, na.rm = narm)

        }

        if (st == "qrange") {

          q25 <- quantile(var, probs = c(0.25), type = 2, na.rm = narm)
          q75 <- quantile(var, probs = c(0.75), type = 2, na.rm = narm)

          rw[["QRange"]] <- q75 - q25

        }


      }

    }

    if (is.null(ret))
      ret <- rw
    else
      ret <- rbind(ret, rw)
  }


  return(ret)

}


